//#domain
//cpp imports here
#include "SymbolTable.h"
#include "wchar.h"
//#enddomain

COMPILER Zoso

    int plus, minus, times, slash, equals, lessThan, greaterThan, assign; // Operators
    int undef, integer, boolean, decimal; // types
    int var, function; //Object Kinds


    int ADD, SUB, MUL, DIV, EQU, LSS, GTR, ASSIGN; // operation codes

    void InitDeclarations() {
        plus = 0, minus = 1, times = 2, slash = 3, equals = 4, lessThan = 5, greaterThan = 6, assign = 7;
        integer = 1, boolean = 2, decimal = 3;
        var = 0, function = 1;

        // Operational Codes
        ADD = 0, SUB = 1, MUL = 2, DIV = 3, EQU = 4, LSS = 5, GTR = 6, ASSIGN = 7;
    }
    SymbolTable *symbolTable;

CHARACTERS
    letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
    digit = "0123456789".
    quote = '\"'.
    cr  = '\r'.
    lf  = '\n'.
    tab = '\t'.
    space = ' '.

TOKENS
    ident = letter { letter | digit }.
    string = quote { letter | digit } quote.
    number = digit {digit} | digit {digit} CONTEXT ("..").
    float = digit {digit} '.' {digit}. 

IGNORE cr + lf + tab + space

PRODUCTIONS
    Ident <wchar_t* &name> = 
        ident (. name = coco_string_create(t -> val); .)
    .

    AddOp = '+' | '-'.

    MulOp = '*' | '/'.

    VariableDeclaration (. wchar_t* name; int type; .) = 
        Type<type>
        Ident<name> (. symbolTable -> NewObj(name, var, type); .)
        {',' Ident<name> (. symbolTable -> NewObj(name, var, type); .) } 
    .

    Type<int &type> = ( 
        "int" (. type = integer; .)
        | "bool" (. type = boolean; .)
        | "float" (. type = decimal; .)
        | "void" (. type = undef; .)
    ).

    FunctionDeclaration (. wchar_t* name; int type; .) = 
        "function" Type<type>  
        Ident<name> (. symbolTable -> NewObj(name, function, type); .)
        '(' (. symbolTable -> OpenScope(); .) { VariableDeclaration ';' } ')' 
        '{' { Statement }'}' 
        (. symbolTable -> CloseScope(); .)
    .

    // IfCase (. int& type; .) = 
    //     "if" '(' LogicalExpresion<type> ')' '{'
    //         (. symbolTable -> OpenScope(); .)
    //         { Statement }
    //         (. symbolTable -> CloseScope(); .)
    //     '}'
    //     [ "else" '{' 
    //         (. symbolTable -> OpenScope(); .)
    //         { Statement } 
    //         (. symbolTable -> CloseScope(); .)
    //     '}']
    // .

    // WhileLoop (. int& type; .) = 
    //     "while" '(' LogicalExpresion<type> ')' '{' 
    //         (. symbolTable -> OpenScope(); .)
    //         { Statement } 
    //         (. symbolTable -> CloseScope(); .)
    //     '}'
    // .

    Statement (. int type; wchar_t* name; Obj* obj;.) = (
        | Ident<name> (.
            obj = symbolTable -> Find(name);
            type = obj -> type;
        .) (
            |'=' LogicalExpresion<type>
            | '(' [LogicalExpresion<type>] ')'
        )
        | FunctionDeclaration
        | VariableDeclaration
    ) ';'
    .

    LogicalExpresion<int& type> (. int nextType; .) = 
        SimExpr<type> [ ( "==" | '<' | '>' ) SimExpr<nextType> ] 
    .

    SimExpr<int& type> (. int nextType; .) =  
        Term<type> {
            AddOp Term<nextType> (. 
                if (type != integer || nextType != integer) throw std::invalid_argument("integer type expected"); // add float logic
            .)
        }
    .

    Term<int& type> (. int nextType; .) =
        Factor<type> {
            MulOp Factor<nextType> (. 
                if (type != integer || nextType != integer) throw std::invalid_argument("integer type expected"); // add float logic
            .)
        }.

    Factor<int& type> (. wchar_t* name;  Obj* obj;  int numberReference;.) =
        (. type = undef; .)
        number (. type = integer; swscanf(t -> val, L"%d", &numberReference); .) // convert to int
        | // la == Identification
            Ident<name> (.
                obj = symbolTable -> Find(name);
                type = obj -> type;
            .) 
            [IF( obj -> kind == function ) 
                '(' [ 
                    (. int& typeFunctionVar = undef; .)
                    Factor<typeFunctionVar> { 
                        (. int& typeFunctionSubsequentVar = undef; .)
                         ',' Factor<typeFunctionSubsequentVar> 
                    }
                ] ')' 
            ] (.
                else if (obj -> kind != var) throw std::invalid_argument("identifier not a variable"); 
            .)
        | '(' SimExpr<type> ')' 
        | '-' Factor<type>
    .

    Zoso (. wchar_t* name; InitDeclarations(); .) = 
        "Program" (. symbolTable -> OpenScope(); .)
        '{' 
            { Statement }
        '}'
        (. symbolTable -> CloseScope(); .)
    .
END Zoso.

/*-------------------

TODO:
variable assignation

add floats

logical operations

numbers are not being typed correctly

strings are not being parsed

-----------------------------------------------------*/
