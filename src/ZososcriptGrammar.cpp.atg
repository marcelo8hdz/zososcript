//#domain
//cpp imports here
#include "SymbolTable.h"
#include "wchar.h"
//#enddomain

COMPILER Zoso

    int plus, minus, times, slash, equals, lessThan, greaterThan, assign; // Operators
    int undef, integer, boolean, decimal; // types
    int var, function; //Object Kinds


    int ADD, SUB, MUL, DIV, EQU, LSS, GTR, ASSIGN; // operation codes

    void InitDeclarations() {
        plus = 0, minus = 1, times = 2, slash = 3, equals = 4, lessThan = 5, greaterThan = 6, assign = 7;
        integer = 1, boolean = 2, decimal = 3;
        var = 0, function = 1;

        // Operational Codes
        ADD = 0, SUB = 1, MUL = 2, DIV = 3, EQU = 4, LSS = 5, GTR = 6, ASSIGN = 7;
    }
    SymbolTable *symbolTable;

CHARACTERS
    letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
    digit = "0123456789".
    quote = '\"'.
    cr  = '\r'.
    lf  = '\n'.
    tab = '\t'.
    space = ' '.

TOKENS
    number = digit { digit } [ '.'] { digit }.
    ident = letter { letter | digit }.
    string = quote { letter | digit } quote.

IGNORE cr + lf + tab + space

PRODUCTIONS
    Ident <wchar_t* &name> = 
        ident (. name = coco_string_create(t -> val); .)
    .

    AddOp = '+' | '-'.

    MulOp = '*' | '/'.

    VariableDeclaration (. wchar_t* name; int type; .) = 
        Type<type>
        Ident<name> (. symbolTable -> NewObj(name, var, type); .)
        {',' Ident<name> (. symbolTable -> NewObj(name, var, type); .) } 
        ';'
        
    .
    Type<int &type> =                        
        ( 
            "int" (. type = integer; .)
            | "bool" (. type = boolean; .)
            | "float" (. type = decimal; .)
            | "void" (. type = undef; .)
        )
    .

    FunctionDeclaration (. wchar_t* name; int type; .) = 
        "function" Type<type>  
        Ident<name> (. symbolTable -> NewObj(name, function, type); .)
         '(' { VariableDeclaration } ')' 
         '{' { Statement }'}'
    .

    Statement (. int type; .) =
        "print" '(' { string | Expr<type> } ')' ';' 
        | Expr<type> 
        | FunctionDeclaration
        | VariableDeclaration
    .

    Expr<int& type> (. int nextType; .) = 
        SimExpr<type> [ ( "==" | '<' | '>' ) SimExpr<nextType> ] ';'.

    SimExpr<int& type> (. int nextType; .) =  
        Term<type> {
            AddOp Term<nextType> (. 
                if (type != integer || nextType != integer) throw std::invalid_argument("integer type expected"); // add float logic
            .)
        }.

    Term<int &type> (. int nextType; .) =
        Factor<type> {
            MulOp Factor<nextType> (. 
                if (type != integer || nextType != integer) throw std::invalid_argument("integer type expected"); // add float logic
            .)
        }.

    Factor<int &type> (. wchar_t* name;  Obj* obj;  int numberReference;.) =
        (. type = undef; .)
        number (. swscanf(t -> val, L"%d", &numberReference); .) // convert to int
        | Ident<name> (.
            obj = symbolTable -> Find(name);
            type = obj -> type;
            if (obj -> kind != var) throw std::invalid_argument("identifier undeclared"); 
        .)
        | '(' SimExpr<type> ')' 
        | '-' Factor<type>
    .

    Zoso (. wchar_t* name; InitDeclarations(); .) = 
        "Program" (. symbolTable -> OpenScope(); .)
        '{' 
            { Statement }
        '}'
        (. symbolTable -> CloseScope(); .)
    .
END Zoso.

/*-------------------

TODO:
function call -> hoping this fixes necesity of print in grammar
variable assignation
add floats
change function declared variables scope

print shouldn't be in grammar? its more like its own method -> grammar gets fucked with out it doe

logical operations

move variable ';' to after expresion to avoid print(VARIABLE_NAME;); ;-> inside parenthesis

string are not being parsed

-----------------------------------------------------*/
